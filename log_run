#!/bin/bash

if [[ -f $(dirname $(realpath $0))/options_parser.sh ]]; then
  source $(dirname $(realpath $0))/options_parser.sh
elif [[ -f $(dirname $0)/options_parser.sh ]]; then
  source $(dirname $0)/options_parser.sh
else
  echo "no options_parser found ..." >&2
  exit 13
fi

op_description="run jobs which are failed in previous running, log the
status for further retries."

OP_add_help

declare wrapper log_file job_file
declare -a run_jobs
declare parallel=0
declare at_job

OP_add_option "wrapper" "wrapper" "Command to wrap and run"

OP_add_option "log-file" "log_file" "FILE\nfile to log read and write
job-id status and environment"

OP_add_option "job-file" "job_file" "FILE\nfile to read commands"

OP_add_option "run-jobs" "OP_take_extend run_jobs regex ^[0-9]+$ --" \
  "NUM+\njobs to run"

OP_add_option "environment" "environment" "STR\nenvironment, if not
changed, status will not change, to avoid not necessary retry."

OP_add_option "parallel" "OP_take_set_check parallel regex ^[0-9]+$ --" \
  "NUM\nrun in parallel with NUM processors."

# hiden option
OP_add_option "AT-JOB" "OP_take_set_check at_job regex ^[0-9]+$ --" "" ""

OP_parse_all "$@"

if [[ -z "$environment" || "$environment" = "git-head" ]]; then
  environment="$(git log HEAD~..HEAD | head -n 1 | sed 's/commit //')"
  if test $? -ne 0; then
    echo "got environment failed ..." >&2
    exit 1
  fi
fi

function die {
  echo "$@" >&2
  exit 1
}

[[ -n "$job_file" ]] || die "no job file"
[[ -n "$log_file" ]] || die "no log file"

mapfile -t jobs <"$job_file"

function log_status {
  local l_jobid=$1
  local l_status=$2
  # TODO: I think/guess, this is atomically in most case
  echo "$l_jobid $l_status $environment" >> $log_file
}

function run_job {
  local l_jobid="$1"
  shift
  local l_status=$(grep "^$l_jobid " $log_file | tail -n 1)
  if [[ $l_status =~ " 0" ]]; then
    return 0
  fi
  local l_last_env=$(echo $l_status | sed 's/ /\n/g' | tail -n 1)
  if test x"$l_last_env" = x"$environment"; then
    echo "#$l_jobid ${jobs[l_jobid]} keep failed as $environment ... " >&2
  else
    echo "run job #$l_jobid ${jobs[l_jobid]} ... " >&2
    $wrapper ${jobs[l_jobid]}
    local l_status=$?
    log_status $l_jobid $l_status
  fi
}

if [[ -n "$at_job" ]]; then
  run_job $at_job
  exit
fi


if [[ ${#run_jobs[@]} -eq 0 ]]; then
  mapfile -t run_jobs < <( seq 0 $(( ${#jobs[@]} - 1)) )
fi

if [[ "$parallel" -ge 2 ]]; then
  parallel -j $parallel $0 "$@" --AT-JOB -- "${run_jobs[@]}"
else
  for jobid in ${run_jobs[@]}; do
    run_job $jobid ${jobs[jobid]}
  done
fi
